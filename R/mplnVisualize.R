#' Visualize Clustered Results Via MPLN
#'
#' A function to visualize the clustering results obtained from a
#'  mixtures of multivariate Poisson-log normal (MPLN) model. This
#'  function produces heatmaps and line plots.
#'
#' @param dataset A dataset of class matrix and type integer such that
#'    rows correspond to observations and columns correspond to variables.
#' @param clusterMembershipVector A numeric vector of length nrow(dataset)
#'    containing the cluster membership of each observation as generated by
#'    mpln(). Default NA.
#' @param fileName Name for the plot being generated.
#' @param plots A character string indicating which plots to be produced.
#'    Options are 'heatmaps', 'lines', and 'all'. Default is 'all'.
#' @param format Character string indicating the format of the image to
#'    be produced. Default 'pdf'. Options 'pdf' or 'png'.
#'
#' @return Plotting function provides the possibility for line and heatmap
#'    plots.
#'
#' @examples
#' # Generating simulated data
#' # Not run
#' # trueMu1 <- c(6.5, 6, 6, 6, 6, 6)
#' # trueMu2 <- c(2, 2.5, 2, 2, 2, 2)
#'
#' # trueSigma1 <- diag(6) * 2
#' # trueSigma2 <- diag(6)
#'
#' # simulatedCounts <- mplnDataGenerator(nObservations = 70,
#' #                                       dimensionality = 6,
#' #                                       mixingProportions = c(0.79, 0.21),
#' #                                       mu = rbind(trueMu1, trueMu2),
#' #                                       sigma = rbind(trueSigma1, trueSigma2),
#' #                                       produceImage = "No")
#'
#' # MPLNClustResults <- mpln(dataset = simulatedCounts$dataset,
#' #                          membership = NA,
#' #                          gmin = 2,
#' #                          gmax = 2,
#' #                          nChains = 3,
#' #                          nIterations = 100,
#' #                          initMethod = "kmeans",
#' #                          nInitIterations = 0,
#' #                          normalize = "Yes")
#'
#' # MPLNVisuals <- mplnVisualize(dataset = simulatedCounts$dataset,
#' #                              clusterMembershipVector =
#' #                  MPLNClustResults$all_results[[1]]$all_results$clusterlabels,
#' #                               fileName = 'TwoClusterModel', plots = 'all',
#' #                               format = 'png')
#'
#' @author Anjali Silva, \email{anjali.silva@uhnresearch.ca}
#'
#' @export
#' @import graphics
#' @importFrom gplots heatmap.2
#' @import pheatmap
#' @import grDevices
#' @import RColorBrewer
#' @importFrom gplots redgreen
mplnVisualize <- function(dataset, clusterMembershipVector = NA,
                          fileName = 'FileName', plots = 'all',
                          format = 'pdf') {

  # Checking

  if (typeof(dataset) != "double" & typeof(dataset) != "integer") {
    stop("\n Dataset type needs to be integer")
  }

  if (class(dataset) != "matrix") {
    stop("\n Dataset needs to be a matrix")
  }

  if (class(clusterMembershipVector) == "logical") {
    cat("\n clusterMembershipVector is not provided.")
    clusterMembershipVector <- rep(1, nrow(dataset))

  } else if (class(clusterMembershipVector) == "numeric") {
    if (nrow(dataset) != length(clusterMembershipVector)) {
      stop("\n length(clusterMembershipVector) should match
        nrow(dataset)")
    }
  }

  # Obtaining path to save images
  pathNow <- getwd()

  # Saving cluster membership for each observation
  DataPlusLabs <- cbind(dataset, clusterMembershipVector)
  ordervector <- anothervector <- list()

  for (i in 1:max(clusterMembershipVector)) {
    ordervector[[i]] <- which(DataPlusLabs[,
                ncol(dataset) + 1] == i)
    anothervector[[i]] <- rep(i,
                length(which(DataPlusLabs[,
                ncol(dataset) + 1] == i)))
  }

  vec <- unlist(ordervector)
  colorsvector <- unlist(anothervector)

  qual_col_pals <- RColorBrewer::brewer.pal.info[brewer.pal.info$category == 'qual',]
  col_vector <- unlist(mapply(RColorBrewer::brewer.pal,
                       qual_col_pals$maxcolors,
                       rownames(qual_col_pals)))

  pathNow <- getwd()

  if (plots == 'all' || plots == 'heatmaps') {
  # Heatmap 1
    if (format == 'png') {
      grDevices::png(paste0(pathNow, "/heatmap1_", fileName, ".png"))
    } else {
      grDevices::pdf(paste0(pathNow, "/heatmap1_", fileName, ".pdf"))
    }
    gplots::heatmap.2(as.matrix(dataset[vec, ]),
                      dendrogram = "column",
                      trace = "none",
                      scale = "row",
                      Rowv = FALSE, col = rev(gplots::redgreen(75)),
                      RowSideColor = col_vector[colorsvector + 1],
                      labRow = FALSE,
                      main = paste("Clustering results, G =",
                             max(clusterMembershipVector)))
    graphics::par(xpd = TRUE)
    graphics::legend("topright",
      legend = paste0("Cluster ", unique(colorsvector)),
      col = unique(col_vector[colorsvector + 1]),
      lty = 1,
      lwd = 5,
      cex =.8,  xpd = TRUE, horiz = FALSE)
    grDevices::dev.off()

  # Heatmap 2
  annotation_row = data.frame(
    Cluster = factor(clusterMembershipVector[vec]))
  if(is.null(rownames(dataset)) == TRUE) {
    rownames(dataset)  = paste("Gene", c(1:nrow(dataset[vec, ])))
    rownames(annotation_row) = rownames(dataset[vec, ])
  }else {
    rownames(annotation_row) = rownames(dataset[vec, ])
  }

  if (format == 'png') {
    grDevices::png(paste0(pathNow, "/heatmap2_", fileName, ".png"))
  } else {
    grDevices::pdf(paste0(pathNow, "/heatmap2_", fileName, ".pdf"))
  }
  pheatmap::pheatmap(as.matrix(dataset[vec, ]), show_colnames = T,
           labels_col = colnames(dataset),
           annotation_row = annotation_row,
           fontface = "italic", legend = T, scale ="row",
           border_color = "black", cluster_row = FALSE,
           cluster_col = FALSE,
           color =  rev(gplots::redgreen(1000)) )
  grDevices::dev.off()
  }

  if (plots == 'all' || plots == 'lines') {
  # Line Plots
    for(cluster in seq_along(unique(clusterMembershipVector))) {

      if (format == 'png') {
        grDevices::png(paste0(pathNow, "/LinePlot_Cluster", cluster,
          "_", fileName, ".png"))
      } else {
        grDevices::pdf(paste0(pathNow, "/LinePlot_Cluster", cluster,
          "_", fileName, ".pdf"))
      }
        # Save how many observations below to each cluster size,
        # given by 'cluster'
        toplot_1 = as.matrix(DataPlusLabs[which(DataPlusLabs[,
          ncol(dataset) + 1] == cluster), c(1:ncol(dataset))],
          ncol = ncol(dataset))

        # Save column mean in last row
        toplot1 = rbind(log(toplot_1 + 1), colMeans(log(toplot_1 + 1)))
        # If discontinunity is needed between samples (e.g. for 6 samples)
        # toplot1_space=cbind(toplot1[,c(1:3)],rep(NA,nrow(toplot_1)+1),
        # toplot1[,c(4:6)])

        if (cluster == 7) {
          # alter the colour from yellow, since yellow is used as
          # average line colour
          graphics::matplot(t(toplot1), type = "l", pch = 1,
                  col = c(rep("maroon", nrow(toplot_1)), 7),
                  xlab = "Samples", ylab = "Expression (log counts)",
                  cex = 1, lty = c(rep(2, nrow(toplot_1)), 1),
                  lwd = c(rep(1, nrow(toplot_1)), 3), xaxt = "n",
                  xlim = c(1, ncol(toplot1)), main = paste("Cluster ",
                  cluster))
        } else {
          graphics::matplot(t(toplot1), type = "l", pch = 1,
            col = c(rep(cluster, nrow(toplot_1)), 7),
            xlab = "Samples", ylab = "Expression (log counts)", cex = 1,
            lty = c(rep(2, nrow(toplot_1)), 1),
            lwd = c(rep(1, nrow(toplot_1)), 3),
            xaxt = "n", xlim = c(1, ncol(toplot1)),
            main = paste("Cluster ", cluster)) }
        axis(1, at = c(1:ncol(dataset)), labels = colnames(dataset))
        grDevices::dev.off()
    }
  }
}
