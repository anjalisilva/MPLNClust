#' Visualize Clustered Results Via MPLN
#'
#' A function to visualize data and clustering results obtained
#' from a mixtures of multivariate Poisson-log normal (MPLN) model.
#' The function produces heatmaps and line plots of input data.
#' If cluster membership of observations are provided, this
#' information will be indicated in the figures. If a matrix of
#' probabilities for the observations belonging to each cluster
#' is provided, the option to produce a barplot of probabilities
#' is also available.
#'
#'
#' @param dataset A dataset of class matrix and type integer such that
#'    rows correspond to observations and columns correspond to variables.
#' @param plots A character string indicating which plots to be produced.
#'    Options are 'heatmaps', 'lines', 'bar', and 'all'. Default is 'all'.
#' @param probabilities A matrix of size N x C, such that rows correspond
#'    to N observations and columns correspond to C clusters. Each row
#'    should sum to 1. Default is NA.
#' @param clusterMembershipVector A numeric vector of length nrow(dataset)
#'    containing the cluster membership of each observation as generated by
#'    mpln(). Default is NA.
#' @param fileName Unique character string indicating the name for the plot
#'    being generated. Default is Plot_date, where date is obtained from
#'    date().
#' @param LinePlotColours Character string indicating if the line plots
#'    should be multicoloured or monotone, in black. Options are
#'    'multicolour' or 'black'. Default is 'black'.
#' @param format Character string indicating the format of the image to
#'    be produced. Default 'pdf'. Options 'pdf' or 'png'.
#'
#' @return Plotting function provides the possibility for line and heatmap
#'    plots.
#'
#' @examples
#' # Generating simulated data
#' # Not run
#' # trueMu1 <- c(6.5, 6, 6, 6, 6, 6)
#' # trueMu2 <- c(2, 2.5, 2, 2, 2, 2)
#'
#' # trueSigma1 <- diag(6) * 2
#' # trueSigma2 <- diag(6)
#'
#' # simulatedCounts <- mplnDataGenerator(nObservations = 70,
#' #                                      dimensionality = 6,
#' #                                      mixingProportions = c(0.79, 0.21),
#' #                                      mu = rbind(trueMu1, trueMu2),
#' #                                      sigma = rbind(trueSigma1, trueSigma2),
#' #                                      produceImage = "No")
#'
#' # MPLNClustResults <- mplnParallel(dataset = simulatedCounts$dataset,
#' #                                  membership = "none",
#' #                                  gmin = 2,
#' #                                  gmax = 2,
#' #                                  nChains = 3,
#' #                                  nIterations = 200,
#' #                                  initMethod = "kmeans",
#' #                                  nInitIterations = 0,
#' #                                  normalize = "Yes")
#'
#' # MPLNVisuals <- mplnVisualize(dataset = simulatedCounts$dataset,
#' #                              plots = 'all',
#' #                              clusterMembershipVector =
#' #                              MPLNClustResults$all_results[[1]]$all_results$clusterlabels,
#' #                              fileName = 'TwoClusterModel',
#' #                              format = 'png')
#'
#' @author Anjali Silva, \email{anjali.silva@uhnresearch.ca}
#'
#' @export
#' @import graphics
#' @import ggplot2
#' @importFrom grDevices png
#' @importFrom grDevices pdf
#' @importFrom grDevices dev.off
#' @importFrom RColorBrewer brewer.pal.info
#' @importFrom RColorBrewer brewer.pal
#' @importFrom randomcoloR distinctColorPalette
#' @importFrom pheatmap pheatmap
#' @importFrom gplots heatmap.2
#' @importFrom gplots redgreen
mplnVisualize <- function(dataset, plots = 'all',
                          probabilities = NA,
                          clusterMembershipVector = NA,
                          fileName = paste0('Plot_',date()),
                          LinePlotColours = "black",
                          format = 'pdf') {

  # Checking user input
  if (typeof(dataset) != "double" & typeof(dataset) != "integer") {
    stop("\n Dataset type needs to be integer")
  }

  if (class(dataset) != "matrix") {
    stop("\n Dataset needs to be a matrix")
  }

  if (class(clusterMembershipVector) == "logical") {
    cat("\n clusterMembershipVector is not provided.")
    clusterMembershipVector <- rep(1, nrow(dataset))

  } else if (class(clusterMembershipVector) == "numeric") {
      if (nrow(dataset) != length(clusterMembershipVector)) {
        stop("\n length(clusterMembershipVector) should match
          nrow(dataset)")
      }
  }

  if (class(probabilities) == "logical") {
    cat("\n Probabilities are not provided. Barplot of probabilities will not be produced.")
  } else if (class(probabilities) == "matrix") {
      if (nrow(probabilities) != length(clusterMembershipVector)) {
        stop("\n length(probabilities) should match nrow(dataset)")
      }
      if (any(rowSums(probabilities) >= 1.01)) {
        stop("\n rowSums(probabilities) reveals at least
          one observation has probability != 1.")
      }
      if (any(rowSums(probabilities) <= 0.99)) {
        stop("\n rowSums(probabilities) reveals at least
          one observation has probability != 1.")
      }
  }

  # Obtaining path to save images
  pathNow <- getwd()

  # Saving cluster membership for each observation
  DataPlusLabs <- cbind(dataset, clusterMembershipVector)
  ordervector <- anothervector <- list()

  # Divide observations into each cluster based on membership
  for (i in 1:max(clusterMembershipVector)) {
    ordervector[[i]] <- which(DataPlusLabs[,
                ncol(dataset) + 1] == i)
    # divide observations as an integer based on cluster membership
    anothervector[[i]] <- rep(i,
                length(which(DataPlusLabs[,
                ncol(dataset) + 1] == i)))
  }

  vec <- unlist(ordervector) # put observations in order of cluster membership
  colorsvector <- unlist(anothervector) # put all details together as integers

  # Setting the colours
  if(max(clusterMembershipVector) > 17) {
    qual_col_pals <- RColorBrewer::brewer.pal.info[brewer.pal.info$category == 'qual', ]
    coloursBarPlot <- unlist(mapply(RColorBrewer::brewer.pal,
                                    qual_col_pals$maxcolors,
                                    rownames(qual_col_pals)))
  } else {
    coloursBarPlot <- c('#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6',
                        '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324',
                        '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1',
                        '#000075', '#808080')
  }



  if (plots == 'all' || plots == 'heatmaps') {
  # Heatmap 1

    if (format == 'png') {
      grDevices::png(paste0(pathNow, "/heatmap1_", fileName, ".png"))
    } else {
      grDevices::pdf(paste0(pathNow, "/heatmap1_", fileName, ".pdf"))
    }

    gplots::heatmap.2(as.matrix(dataset[vec, ]),
                      dendrogram = "column",
                      trace = "none",
                      scale = "row",
                      Rowv = FALSE, col = rev(gplots::redgreen(75)),
                      RowSideColor = coloursBarPlot[colorsvector],
                      labRow = FALSE,
                      main = paste("Clustering results, G =",
                             max(clusterMembershipVector)))
    graphics::par(xpd = TRUE)
    graphics::legend( xpd = TRUE, x = -0.1, y= 0,
      legend = paste0("Cluster ", unique(colorsvector)),
      col = unique(coloursBarPlot[colorsvector]),
      lty = 1,
      lwd = 5,
      cex =.8, horiz = FALSE)
    grDevices::dev.off()



    # Heatmap 2 - only produced if less than 17 clusters
    if(max(clusterMembershipVector) < 18) {
      # Defining annotation row
      annotation_row = data.frame(Cluster = factor(clusterMembershipVector[vec]))
      if(is.null(rownames(dataset)) == TRUE) {
        rownames(dataset)  = paste("Gene", c(1:nrow(dataset[vec, ])))
        rownames(annotation_row) = rownames(dataset[vec, ])
      } else {
        rownames(annotation_row) = rownames(dataset[vec, ])
      }

      # Define row annotation colours
      heatMap2RowAnnotation <- c("1" = coloursBarPlot[1], "2" = coloursBarPlot[2],
                                 "3" = coloursBarPlot[3], "4" = coloursBarPlot[4],
                                 "5" = coloursBarPlot[5], "6" = coloursBarPlot[6],
                                 "7" = coloursBarPlot[7], "8" = coloursBarPlot[8],
                                 "9" = coloursBarPlot[9], "10" = coloursBarPlot[10],
                                 "11" = coloursBarPlot[11], "12" = coloursBarPlot[12],
                                 "13" = coloursBarPlot[13], "14" = coloursBarPlot[14],
                                 "15" = coloursBarPlot[15], "16" = coloursBarPlot[16],
                                 "17" = coloursBarPlot[17])

      if (format == 'png') {
        grDevices::png(paste0(pathNow, "/heatmap2_", fileName, ".png"))
      } else {
        grDevices::pdf(paste0(pathNow, "/heatmap2_", fileName, ".pdf"))
      }

      # Show row names or not based on dataset size
      if(nrow(dataset) < 50){
        showLabels = TRUE
      } else {
        showLabels = FALSE
      }
      pheatmap::pheatmap(as.matrix(dataset[vec, ]), show_colnames = TRUE,
                         show_rownames = showLabels,
                         labels_col = colnames(dataset),
                         annotation_row = annotation_row,
                         annotation_colors = list(Cluster = heatMap2RowAnnotation[
                           sort(unique(clusterMembershipVector))]),
                         fontface = "italic", legend = TRUE, scale ="row",
                         border_color = "black", cluster_row = FALSE,
                         cluster_col = FALSE,
                         color =  rev(gplots::redgreen(1000)) )
      grDevices::dev.off()
    }
  }



  if (plots == 'all' || plots == 'lines') {
  # Line Plots

    if (LinePlotColours == "multicolour") {
      for(cluster in unique(clusterMembershipVector)) {
        if (format == 'png') {
          grDevices::png(paste0(pathNow, "/LinePlot_Cluster", cluster,
            "_", fileName, ".png"))
        } else {
          grDevices::pdf(paste0(pathNow, "/LinePlot_Cluster", cluster,
            "_", fileName, ".pdf"))
        }

        # Save how many observations below to each cluster size,
        # given by 'cluster'

        if (length(which(DataPlusLabs[, ncol(dataset) + 1] == cluster)) == 1) {
          toplot_1 <- as.matrix(DataPlusLabs[which(DataPlusLabs[,
                                 ncol(dataset) + 1] == cluster), c(1:ncol(dataset))],
                                ncol = ncol(dataset))
          rownames(toplot_1) <- names(which(DataPlusLabs[, ncol(dataset) + 1] == cluster))
        } else if (length(which(DataPlusLabs[, ncol(dataset) + 1] == cluster)) > 1) {
          toplot_1 <- as.matrix(DataPlusLabs[which(DataPlusLabs[,
                                ncol(dataset) + 1] == cluster), c(1:ncol(dataset))],
                                ncol = ncol(dataset))
        }

        # Save column mean in last row
        toplot1 <- rbind(log(toplot_1 + 1), colMeans(log(toplot_1 + 1)))
        # If discontinunity is needed between samples (e.g. for 6 samples)
        # toplot1_space=cbind(toplot1[,c(1:3)],rep(NA,nrow(toplot_1)+1),
        # toplot1[,c(4:6)])

        graphics::matplot(t(toplot1), type = "l", pch = 1,
                          col = c(rep(coloursBarPlot[cluster], nrow(toplot_1)), 7),
                          xlab = "Samples", ylab = "Expression (log counts)", cex = 1,
                          lty = c(rep(2, nrow(toplot_1)), 1),
                          lwd = c(rep(3, nrow(toplot_1)), 4),
                          xaxt = "n", xlim = c(1, ncol(toplot1)),
                          main = paste("Cluster ", cluster))
        axis(1, at = c(1:ncol(dataset)), labels = colnames(dataset))
        grDevices::dev.off()
      }
    } else if (LinePlotColours == "black") {
      for(cluster in unique(clusterMembershipVector)) {

        if (format == 'png') {
          grDevices::png(paste0(pathNow, "/LinePlot_Cluster", cluster,
            "_", fileName, ".png"))
        } else {
          grDevices::pdf(paste0(pathNow, "/LinePlot_Cluster", cluster,
            "_", fileName, ".pdf"))
        }
        # Save how many observations below to each cluster size,
        # given by 'cluster'
        if (length(which(DataPlusLabs[, ncol(dataset) + 1] == cluster)) == 1) {
          toplot_1 <- t(as.matrix(DataPlusLabs[which(DataPlusLabs[,
            ncol(dataset) + 1] == cluster), c(1:ncol(dataset))],
            ncol = ncol(dataset)))
          rownames(toplot_1) <- names(which(DataPlusLabs[, ncol(dataset) + 1] == cluster))
        } else if (length(which(DataPlusLabs[, ncol(dataset) + 1] == cluster)) > 1) {
          toplot_1 <- as.matrix(DataPlusLabs[which(DataPlusLabs[,
            ncol(dataset) + 1] == cluster), c(1:ncol(dataset))],
            ncol = ncol(dataset))
        }

        # Save column mean in last row
        toplot1 <- rbind(log(toplot_1 + 1), colMeans(log(toplot_1 + 1)))
        # If discontinunity is needed between samples (e.g. for 6 samples)
        # toplot1_space=cbind(toplot1[,c(1:3)],rep(NA,nrow(toplot_1)+1),
        # toplot1[,c(4:6)])

        graphics::matplot(t(toplot1), type = "l", pch = 1,
                          col = c(rep(1, nrow(toplot_1)), 7),
                          xlab = "Samples", ylab = "Expression (log counts)", cex = 1,
                          lty = c(rep(2, nrow(toplot_1)), 1),
                          lwd = c(rep(3, nrow(toplot_1)), 4),
                          xaxt = "n", xlim = c(1, ncol(toplot1)),
                          main = paste("Cluster ", cluster))
        axis(1, at = c(1:ncol(dataset)), labels = colnames(dataset))
        grDevices::dev.off()
      }
    }
  }



  if ((plots == 'all' || plots == 'bar') && !is.na(probabilities)) {
    # Bar plot

    tableProbabilities <- as.data.frame(cbind(Sample = c(1:nrow(probabilities)),
                                        Cluster = mclust::map(probabilities),
                                        probabilities))

    names(tableProbabilities) <- c("Sample", "Cluster",
                                   paste0("P", rep(1:(ncol(tableProbabilities)-2))))

    tableProbabilitiesMelt <- reshape::melt(tableProbabilities,
                                            id.vars = c("Sample","Cluster"))


    ggplot2::ggplot(data = tableProbabilitiesMelt,
        ggplot2::aes(fill = variable, y = value, x = Sample)) +
        geom_bar(position = "fill", stat = "identity") +
        scale_fill_manual(values = coloursBarPlot,
          name = "Cluster") + theme_bw() +
        theme(text = element_text(size = 10),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text.x = element_text(face = "bold", angle = 90),
          axis.text.y = element_text(face="bold")) +
        coord_cartesian(ylim = c(0, 1), xlim = c(1, nrow(probabilities))) +
        labs(x = "Observation") +
        scale_y_continuous(name = "Posterior probability", limits = c(0: 1))
    ggplot2::ggsave(paste0(pathNow,"/barplot_", fileName,".",format))
  }

  return(NULL)
}
